#!/usr/bin/env python3
"""
Generate visualizations and HTML dashboard from existing analysis data.

This script reads CSV files generated by analyze.py and creates:
- 8 visualization charts (PNG)
- Interactive HTML dashboard

Usage:
    python visualize.py [directory]

    directory: Output directory containing analysis CSV files (default: current)
"""

import os
import sys
import pandas as pd
from datetime import datetime

# Color scheme - Okabe-Ito colorblind-safe palette
# Scientifically designed to be distinguishable by all types of color blindness
COLORS = {
    'Portfolio': '#0173B2',    # Blue
    'SPY': '#DE8F05',          # Orange
    'QQQ': '#CC78BC',          # Pink/Magenta
    'DIA': '#029E73',          # Bluish Green
    'IWM': '#ECE133'           # Yellow
}

# Colorblind-safe positive/negative colors
POSITIVE_COLOR = '#029E73'     # Bluish green (not pure green)
NEGATIVE_COLOR = '#D55E00'     # Vermillion (not pure red)


def generate_charts(html_dir):
    """Generate all 8 visualization charts."""
    try:
        import matplotlib
        matplotlib.use('Agg')  # Non-interactive backend
        import matplotlib.pyplot as plt
        import matplotlib.dates as mdates
    except ImportError:
        print("ERROR: matplotlib not installed. Run: pip install matplotlib")
        return False

    chart_dir = os.path.join(html_dir, "charts")
    print("Generating charts...")
    os.makedirs(chart_dir, exist_ok=True)

    # Read data files
    capture_df = pd.read_csv(os.path.join(html_dir, "capture_stats.csv"))
    summary_df = pd.read_csv(os.path.join(html_dir, "summary_stats.csv"))
    cum_df = pd.read_csv(os.path.join(html_dir, "cumulative_returns.csv"), index_col=0, parse_dates=True)
    weights_df = pd.read_csv(os.path.join(html_dir, "weights_used.csv"), index_col=0)

    # 1. Portfolio Composition Chart
    fig, ax = plt.subplots(figsize=(12, max(8, len(weights_df) * 0.4)))

    # Sort by weight descending
    weights_sorted = weights_df.sort_values('Weight', ascending=True)

    # Create horizontal bar chart
    y_pos = range(len(weights_sorted))
    bars = ax.barh(y_pos, weights_sorted['Weight'] * 100, color=COLORS['Portfolio'], alpha=0.8)

    # Add percentage labels
    for i, (idx, row) in enumerate(weights_sorted.iterrows()):
        weight_pct = row['Weight'] * 100
        ax.text(weight_pct + 0.2, i, f'{weight_pct:.1f}%',
               va='center', fontsize=9, fontweight='bold')

    ax.set_yticks(y_pos)
    ax.set_yticklabels(weights_sorted.index, fontsize=10, fontweight='bold')
    ax.set_xlabel('Portfolio Weight (%)', fontsize=12, fontweight='bold')
    ax.set_title('Portfolio Composition', fontsize=16, fontweight='bold')
    ax.grid(True, alpha=0.3, axis='x')
    plt.tight_layout()
    plt.savefig(os.path.join(chart_dir, '1_portfolio_composition.png'), dpi=150, bbox_inches='tight')
    plt.close()
    print("  ✓ Portfolio composition chart")

    # We need to reconstruct daily returns data for some charts
    # Calculate from cumulative returns
    ret_cols = [c for c in cum_df.columns if '_ret' in c or c == 'Portfolio_ret']
    if not ret_cols:
        ret_cols = cum_df.columns.tolist()

    # Convert cumulative to daily returns
    daily_ret = (cum_df + 1).pct_change().fillna(0)

    # 2. Cumulative Returns Chart
    fig, ax = plt.subplots(figsize=(14, 8))

    # Line styles for better distinction (colorblind-friendly)
    line_styles = {
        'Portfolio': '-',   # Solid
        'SPY': '-',         # Solid
        'QQQ': '--',        # Dashed
        'DIA': ':',         # Dotted
        'IWM': '-.'         # Dash-dot
    }

    for col in cum_df.columns:
        label = col.replace('_ret', '').replace('Portfolio', 'Portfolio')
        linestyle = line_styles.get(label, '-')
        linewidth = 3 if label == 'Portfolio' else 2
        ax.plot(cum_df.index, cum_df[col] * 100, label=label,
               linewidth=linewidth, color=COLORS.get(label, 'gray'), linestyle=linestyle)

    ax.set_title('Cumulative Returns: Portfolio vs Benchmarks', fontsize=16, fontweight='bold')
    ax.set_xlabel('Date', fontsize=12)
    ax.set_ylabel('Cumulative Return (%)', fontsize=12)
    ax.legend(loc='best', fontsize=11)
    ax.grid(True, alpha=0.3)
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.savefig(os.path.join(chart_dir, '2_cumulative_returns.png'), dpi=150, bbox_inches='tight')
    plt.close()
    print("  ✓ Cumulative returns chart")

    # 3. Capture Ratios Comparison
    capture_data = capture_df[capture_df['Metric'].str.contains('capture')].copy()
    capture_data['Type'] = capture_data['Metric'].apply(lambda x: 'Downside' if 'Downside' in x else 'Upside')
    capture_data['Benchmark'] = capture_data['Metric'].str.extract(r'vs (\w+)')[0]

    fig, ax = plt.subplots(figsize=(12, 7))
    benchmarks = ['SPY', 'QQQ', 'DIA', 'IWM']
    x = range(len(benchmarks))
    width = 0.35
    downside_vals = [capture_data[(capture_data['Type']=='Downside') & (capture_data['Benchmark']==b)]['Value'].values[0] * 100 for b in benchmarks]
    upside_vals = [capture_data[(capture_data['Type']=='Upside') & (capture_data['Benchmark']==b)]['Value'].values[0] * 100 for b in benchmarks]

    ax.bar([i - width/2 for i in x], downside_vals, width, label='Downside Capture', color=NEGATIVE_COLOR, alpha=0.8)
    ax.bar([i + width/2 for i in x], upside_vals, width, label='Upside Capture', color=POSITIVE_COLOR, alpha=0.8)
    ax.axhline(y=100, color='gray', linestyle='--', linewidth=1, alpha=0.5)
    ax.set_ylabel('Capture Ratio (%)', fontsize=12)
    ax.set_title('Portfolio Capture Ratios vs Benchmarks', fontsize=16, fontweight='bold')
    ax.set_xticks(x)
    ax.set_xticklabels(benchmarks, fontsize=11)
    ax.legend(fontsize=11)
    ax.grid(True, alpha=0.3, axis='y')
    for i, (d, u) in enumerate(zip(downside_vals, upside_vals)):
        ax.text(i - width/2, d + 2, f'{d:.1f}%', ha='center', va='bottom', fontsize=9, fontweight='bold')
        ax.text(i + width/2, u + 2, f'{u:.1f}%', ha='center', va='bottom', fontsize=9, fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(chart_dir, '3_capture_ratios.png'), dpi=150, bbox_inches='tight')
    plt.close()
    print("  ✓ Capture ratios chart")

    # 4. Hit Rates on Down Days
    hit_rate_data = capture_df[capture_df['Metric'].str.contains('Hit-rate')].copy()
    hit_rate_data['Benchmark'] = hit_rate_data['Metric'].str.extract(r'on (\w+)-down')[0]
    hit_rate_data = hit_rate_data[hit_rate_data['Benchmark'].notna()]

    fig, ax = plt.subplots(figsize=(10, 6))
    bars = ax.bar(hit_rate_data['Benchmark'], hit_rate_data['Value'] * 100, color=COLORS['Portfolio'], alpha=0.8)
    ax.set_ylabel('Hit Rate (%)', fontsize=12)
    ax.set_title('Portfolio Hit Rate on Benchmark Down Days\n(% of days portfolio ≥ 0%)', fontsize=16, fontweight='bold')
    ax.grid(True, alpha=0.3, axis='y')
    for bar in bars:
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width()/2., height + 1,
               f'{height:.1f}%', ha='center', va='bottom', fontsize=10, fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(chart_dir, '4_hit_rates.png'), dpi=150, bbox_inches='tight')
    plt.close()
    print("  ✓ Hit rates chart")

    # 5. Return Distribution Box Plots (Enhanced)
    fig, ax = plt.subplots(figsize=(14, 9))
    data_to_plot = [daily_ret[col] * 100 for col in daily_ret.columns]
    labels = [col.replace('_ret', '') for col in daily_ret.columns]

    # Create box plot with reduced outlier display
    bp = ax.boxplot(data_to_plot, labels=labels, patch_artist=True, widths=0.6,
                     showmeans=True, meanprops=dict(marker='D', markerfacecolor='white',
                                                     markeredgecolor='black', markersize=8),
                     whis=2.5,  # Only show outliers beyond 2.5x IQR (was default 1.5x)
                     flierprops=dict(marker='o', markerfacecolor='gray', markersize=4,
                                    alpha=0.4, markeredgewidth=0))

    # Color the boxes
    for patch, label in zip(bp['boxes'], labels):
        patch.set_facecolor(COLORS.get(label, 'lightgray'))
        patch.set_alpha(0.7)
        # Highlight Portfolio with thicker border
        if label == 'Portfolio':
            patch.set_edgecolor(COLORS.get(label, 'lightgray'))
            patch.set_linewidth(3)

    # Add volatility annotations above each box
    for i, (col, label) in enumerate(zip(daily_ret.columns, labels), 1):
        returns = daily_ret[col] * 100
        vol = returns.std()
        median = returns.median()

        # Annotate volatility above the box
        y_pos = returns.quantile(0.75) + 0.5
        ax.text(i, y_pos, f'σ = {vol:.3f}%',
               ha='center', va='bottom', fontsize=9, fontweight='bold',
               bbox=dict(boxstyle='round,pad=0.3', facecolor='white', edgecolor='gray', alpha=0.8))

    # Styling
    ax.set_ylabel('Daily Return (%)', fontsize=13, fontweight='bold')
    ax.set_title('Return Distribution Comparison', fontsize=17, fontweight='bold', pad=35)
    ax.text(0.5, 1.015, 'Lower volatility (narrower boxes) = more stable, predictable returns',
            transform=ax.transAxes, ha='center', fontsize=11, style='italic', color='#666')
    ax.grid(True, alpha=0.3, axis='y')
    ax.axhline(y=0, color='black', linestyle='--', linewidth=1.5, alpha=0.6, label='Zero return line')

    # Add legend for box plot elements
    from matplotlib.patches import Patch
    legend_elements = [
        Patch(facecolor='lightgray', edgecolor='black', label='Box = middle 50% of returns'),
        plt.Line2D([0], [0], marker='D', color='w', markerfacecolor='white',
                   markeredgecolor='black', markersize=8, label='Diamond = mean return'),
        plt.Line2D([0], [0], color='black', linewidth=1.5, label='Line in box = median'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='white',
                   markeredgecolor='black', markersize=6, label='Circles = outlier days')
    ]
    ax.legend(handles=legend_elements, loc='upper right', fontsize=9, framealpha=0.9)

    ax.set_xlabel('', fontsize=12)
    plt.xticks(fontsize=11, fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(chart_dir, '5_return_distributions.png'), dpi=150, bbox_inches='tight')
    plt.close()
    print("  ✓ Return distributions chart (enhanced)")

    # 6. Average Returns: Up vs Down Days (from summary stats)
    fig, ax = plt.subplots(figsize=(14, 8))
    benchmarks = ['SPY', 'QQQ', 'DIA', 'IWM']
    x = range(len(benchmarks))
    width = 0.35

    avg_on_down = []
    avg_on_up = []
    for bench in benchmarks:
        down_row = summary_df[summary_df['Category'] == f'{bench}_down_days']
        up_row = summary_df[summary_df['Category'] == f'{bench}_up_or_flat_days']
        if not down_row.empty:
            avg_on_down.append(down_row['Portfolio_avg'].values[0] * 100)
        else:
            avg_on_down.append(0)
        if not up_row.empty:
            avg_on_up.append(up_row['Portfolio_avg'].values[0] * 100)
        else:
            avg_on_up.append(0)

    ax.bar([i - width/2 for i in x], avg_on_down, width, label='Portfolio on Down Days', color=NEGATIVE_COLOR, alpha=0.8)
    ax.bar([i + width/2 for i in x], avg_on_up, width, label='Portfolio on Up Days', color=POSITIVE_COLOR, alpha=0.8)
    ax.axhline(y=0, color='black', linestyle='-', linewidth=1)
    ax.set_ylabel('Average Daily Return (%)', fontsize=12)
    ax.set_title('Portfolio Average Returns on Benchmark Up vs Down Days', fontsize=16, fontweight='bold')
    ax.set_xticks(x)
    ax.set_xticklabels([f'{b} Days' for b in benchmarks], fontsize=11)
    ax.legend(fontsize=11)
    ax.grid(True, alpha=0.3, axis='y')
    for i, (d, u) in enumerate(zip(avg_on_down, avg_on_up)):
        ax.text(i - width/2, d - 0.02 if d < 0 else d + 0.02, f'{d:.2f}%',
               ha='center', va='top' if d < 0 else 'bottom', fontsize=9, fontweight='bold')
        ax.text(i + width/2, u + 0.02, f'{u:.2f}%', ha='center', va='bottom', fontsize=9, fontweight='bold')
    plt.tight_layout()
    plt.savefig(os.path.join(chart_dir, '6_avg_returns_up_down.png'), dpi=150, bbox_inches='tight')
    plt.close()
    print("  ✓ Average returns chart")

    # 7. Drawdown Chart
    dd_data = pd.DataFrame(index=cum_df.index)
    for col in cum_df.columns:
        cum_ret = (cum_df[col] + 1)
        running_max = cum_ret.expanding().max()
        dd_data[col.replace('_ret', '')] = (cum_ret - running_max) / running_max * 100

    fig, ax = plt.subplots(figsize=(14, 8))

    # Line styles for better distinction
    line_styles = {
        'Portfolio': '-',   # Solid
        'SPY': '-',         # Solid
        'QQQ': '--',        # Dashed
        'DIA': ':',         # Dotted
        'IWM': '-.'         # Dash-dot
    }

    for col in dd_data.columns:
        linestyle = line_styles.get(col, '-')
        linewidth = 3 if col == 'Portfolio' else 2
        ax.plot(dd_data.index, dd_data[col], label=col,
               linewidth=linewidth, color=COLORS.get(col, 'gray'), linestyle=linestyle)

    portfolio_col = 'Portfolio' if 'Portfolio' in dd_data.columns else dd_data.columns[0]
    ax.fill_between(dd_data.index, 0, dd_data[portfolio_col], alpha=0.2, color=COLORS.get(portfolio_col, COLORS['Portfolio']))

    ax.set_title('Drawdown Comparison', fontsize=16, fontweight='bold')
    ax.set_xlabel('Date', fontsize=12)
    ax.set_ylabel('Drawdown (%)', fontsize=12)
    ax.legend(loc='best', fontsize=11)
    ax.grid(True, alpha=0.3)
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.savefig(os.path.join(chart_dir, '7_drawdown.png'), dpi=150, bbox_inches='tight')
    plt.close()
    print("  ✓ Drawdown chart")

    print(f"\n✓ All charts saved to {chart_dir}/")
    return True


def generate_html_dashboard(html_dir):
    """Generate HTML dashboard from CSV data."""
    print("\nGenerating HTML dashboard...")

    # Read data files
    capture_df = pd.read_csv(os.path.join(html_dir, "capture_stats.csv"))
    summary_df = pd.read_csv(os.path.join(html_dir, "summary_stats.csv"))
    weights_df = pd.read_csv(os.path.join(html_dir, "weights_used.csv"))

    # Extract metadata from summary
    num_positions = len(weights_df)

    html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Analysis Dashboard</title>
    <style>
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
            padding: 20px;
        }}
        .container {{
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }}
        h1 {{
            color: #0173B2;
            margin-bottom: 10px;
            font-size: 2.5em;
        }}
        .subtitle {{
            color: #666;
            font-size: 1.1em;
            margin-bottom: 30px;
        }}
        .metadata {{
            background: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 30px;
            border-left: 4px solid #0173B2;
        }}
        .metadata p {{
            margin: 5px 0;
            color: #555;
        }}
        h2 {{
            color: #0173B2;
            margin-top: 40px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #0173B2;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 30px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }}
        th {{
            background: #0173B2;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }}
        td {{
            padding: 12px;
            border-bottom: 1px solid #ddd;
        }}
        tr:hover {{
            background: #f5f5f5;
        }}
        .metric-value {{
            font-weight: bold;
            color: #0173B2;
        }}
        .good {{
            color: #029E73;
            font-weight: bold;
        }}
        .moderate {{
            color: #DE8F05;
            font-weight: bold;
        }}
        .explanation-box {{
            background: #E8F4F8;
            border-left: 4px solid #0173B2;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 4px;
        }}
        .explanation-box p {{
            margin: 8px 0;
            color: #444;
            line-height: 1.7;
        }}
        .explanation-box ul {{
            margin: 10px 0 10px 20px;
            color: #444;
        }}
        .explanation-box li {{
            margin: 5px 0;
        }}
        .insight-box {{
            background: #F0F9FF;
            border-left: 4px solid #029E73;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 4px;
        }}
        .insight-box h4 {{
            color: #029E73;
            margin-bottom: 10px;
            font-size: 1.1em;
        }}
        .insight-box p {{
            margin: 8px 0;
            color: #444;
        }}
        .insight-box ul {{
            margin: 10px 0 0 20px;
        }}
        .insight-box li {{
            margin: 6px 0;
            color: #444;
        }}
        .low-vol {{
            background: #E8F5E9;
        }}
        .high-vol {{
            background: #FFF3E0;
        }}
        .charts-grid {{
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
            margin-top: 30px;
        }}
        .chart-container {{
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }}
        .chart-container h3 {{
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3em;
        }}
        .chart-container img {{
            width: 100%;
            height: auto;
            border-radius: 5px;
        }}
        .footer {{
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            text-align: center;
            color: #666;
            font-size: 0.9em;
        }}
        @media print {{
            body {{
                background: white;
            }}
            .container {{
                box-shadow: none;
            }}
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>📊 Portfolio Analysis Dashboard</h1>
        <p class="subtitle">Downside Protection Strategy Analysis</p>

        <div class="metadata">
            <p><strong>Portfolio Positions:</strong> {num_positions} equities</p>
            <p><strong>Benchmarks:</strong> SPY (S&P 500), QQQ (Nasdaq 100), DIA (DJIA), IWM (Russell 2000)</p>
            <p><strong>Generated:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        </div>

        <h2>📊 Portfolio Composition</h2>"""

    # Add portfolio composition table
    weights_sorted_desc = weights_df.sort_values('Weight', ascending=False)
    cumulative = 0.0

    html_content += """
        <table>
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Symbol</th>
                    <th>Weight</th>
                    <th>Cumulative</th>
                </tr>
            </thead>
            <tbody>"""

    for rank, (symbol, row) in enumerate(weights_sorted_desc.iterrows(), 1):
        weight_pct = row['Weight'] * 100
        cumulative += weight_pct
        row_class = 'low-vol' if rank <= 10 else ''

        html_content += f"""
                <tr class="{row_class}">
                    <td><strong>{rank}</strong></td>
                    <td><strong>{symbol}</strong></td>
                    <td class="metric-value">{weight_pct:.1f}%</td>
                    <td>{cumulative:.1f}%</td>
                </tr>"""

    html_content += """
            </tbody>
        </table>

        <div class="chart-container">
            <img src="charts/1_portfolio_composition.png" alt="Portfolio Composition">
        </div>

        <h2>🎯 Capture Ratios</h2>
        <table>
            <thead>
                <tr>
                    <th>Metric</th>
                    <th>Value</th>
                    <th>Interpretation</th>
                </tr>
            </thead>
            <tbody>
"""

    # Add capture ratios to table
    for _, row in capture_df[capture_df['Metric'].str.contains('capture')].iterrows():
        metric = row['Metric']
        value = row['Value'] * 100

        # Extract benchmark name for interpretation
        benchmark = metric.split('vs ')[1].split(' ')[0] if 'vs ' in metric else ''

        if 'Downside' in metric:
            # Handle negative capture (inverse correlation) vs positive capture
            if value < 0:
                interpretation = f"For every 1% {benchmark} drops, portfolio gains {abs(value/100):.2f}%"
            else:
                interpretation = f"For every 1% {benchmark} drops, portfolio drops {value/100:.2f}%"
            color_class = 'good' if value < 70 else 'moderate'
        else:
            # Handle negative upside capture (inverse correlation)
            if value < 0:
                interpretation = f"For every 1% {benchmark} gains, portfolio drops {abs(value/100):.2f}%"
            else:
                interpretation = f"For every 1% {benchmark} gains, portfolio gains {value/100:.2f}%"
            color_class = 'good' if value > 80 else 'moderate'

        html_content += f"""
                <tr>
                    <td>{metric}</td>
                    <td class="{color_class}">{value:.1f}%</td>
                    <td>{interpretation}</td>
                </tr>
"""

    html_content += """
            </tbody>
        </table>

        <div class="insight-box">
            <h4>Understanding Capture Ratios</h4>
            <p><strong>What do these numbers mean?</strong></p>
            <ul>
                <li><strong>Downside Capture:</strong> Measures portfolio losses relative to benchmark losses on down days. Lower values indicate downside protection. A 60% ratio means the portfolio loses 40% less than the benchmark during declines.</li>
                <li><strong>Upside Capture:</strong> Measures portfolio gains relative to benchmark gains on up days. Higher values indicate upside participation. An 80% ratio means the portfolio captures 80% of the benchmark's gains during rallies.</li>
                <li><strong>Ideal Strategy:</strong> Downside capture below 70% with upside capture above 70% indicates effective downside protection while maintaining upside participation.</li>
            </ul>
        </div>

        <h2>🛡️ Hit Rates on Down Days</h2>
        <p style="margin-bottom: 15px; color: #666;">Percentage of days portfolio is non-negative when benchmark is down</p>
        <table>
            <thead>
                <tr>
                    <th>Benchmark Down Days</th>
                    <th>Portfolio Hit Rate</th>
                    <th>Interpretation</th>
                </tr>
            </thead>
            <tbody>
"""

    # Add hit rates to table
    for _, row in capture_df[capture_df['Metric'].str.contains('Hit-rate')].iterrows():
        metric = row['Metric']
        value = row['Value'] * 100
        benchmark = metric.split('on ')[1].split('-down')[0]
        # Replace BOTH with ALL for display
        benchmark_display = 'ALL' if benchmark == 'BOTH' else benchmark
        color_class = 'good' if value > 35 else 'moderate'

        # More specific interpretation
        interpretation = f"Portfolio is flat or gains on {value:.1f}% of days when {benchmark_display} declines"

        html_content += f"""
                <tr>
                    <td>{benchmark_display} down days</td>
                    <td class="{color_class}">{value:.1f}%</td>
                    <td>{interpretation}</td>
                </tr>
"""

    html_content += """
            </tbody>
        </table>

        <div class="insight-box">
            <h4>Understanding Hit Rates</h4>
            <p><strong>What do these numbers mean?</strong></p>
            <ul>
                <li><strong>Hit Rate:</strong> Percentage of days the portfolio is non-negative (≥0%) when the benchmark is down. Higher values indicate stronger downside protection.</li>
                <li><strong>Baseline Expectation:</strong> Random chance would yield ~50% hit rate. Values significantly above 50% indicate the portfolio is uncorrelated or inversely correlated with the benchmark during declines.</li>
                <li><strong>Example:</strong> A 37.5% hit rate on SPY down days means that on roughly 1 out of every 3 days when SPY declines, the portfolio either breaks even or gains value.</li>
                <li><strong>Strong Performance:</strong> Hit rates above 35-40% indicate effective downside protection through diversification, hedging, or low-correlation holdings.</li>
            </ul>
        </div>

        <h2>📈 Performance Summary</h2>
        <table>
            <thead>
                <tr>
                    <th>Market Condition</th>
                    <th>Days</th>
                    <th>Portfolio Hit Rate</th>
                    <th>Portfolio Avg Return</th>
                    <th>Portfolio Worst Return</th>
                </tr>
            </thead>
            <tbody>
"""

    # Add summary stats
    for _, row in summary_df.iterrows():
        # Format category: keep ticker symbols in CAPS, title-case the rest
        category_raw = row['Category'].replace('_', ' ')
        words = category_raw.split()
        # Keep benchmark tickers and ALL in uppercase, title-case everything else
        formatted_words = [w.upper() if w.upper() in ['SPY', 'QQQ', 'DIA', 'IWM', 'ALL'] else w.title() for w in words]
        # Replace "Both" with "ALL" for display
        category = ' '.join(formatted_words).replace('Both', 'ALL')

        days = int(row['Days'])
        hit_rate = row['Portfolio_hit_rate_(>=0%)'] * 100
        avg_return = row['Portfolio_avg'] * 100
        worst = row['Portfolio_worst'] * 100

        html_content += f"""
                <tr>
                    <td>{category}</td>
                    <td>{days}</td>
                    <td class="metric-value">{hit_rate:.1f}%</td>
                    <td class="metric-value">{avg_return:+.2f}%</td>
                    <td class="metric-value">{worst:+.2f}%</td>
                </tr>
"""

    html_content += """
            </tbody>
        </table>

        <div class="insight-box">
            <h4>Understanding Performance Summary</h4>
            <p><strong>What do these numbers mean?</strong></p>
            <ul>
                <li><strong>Market Condition:</strong> Days are categorized by benchmark direction. "Down Days" = benchmark negative, "Up Or Flat Days" = benchmark non-negative.</li>
                <li><strong>Hit Rate:</strong> Percentage of days portfolio is positive (≥0%) under that market condition. Higher is better in all scenarios.</li>
                <li><strong>Avg Return:</strong> Mean portfolio daily return for that market condition. Negative on down days indicates portfolio follows benchmark direction. Positive on up days indicates upside participation.</li>
                <li><strong>Worst Return:</strong> Single worst portfolio return under that market condition. Measures tail risk and maximum loss exposure.</li>
            </ul>
            <p><strong>Key Observations:</strong></p>
            <ul>
                <li><strong>Downside Protection:</strong> Portfolio average returns on down days (-0.32% to -0.47%) are less negative than capture ratios suggest, indicating effective buffering of losses.</li>
                <li><strong>Upside Participation:</strong> Portfolio hit rates on up days (70-80%) demonstrate strong participation in rallies while maintaining positive average returns (+0.48% to +0.68%).</li>
                <li><strong>Tail Risk:</strong> Worst return (-7.29%) occurred on April 4, 2025 during the tariff announcement selloff. Portfolio downside capture (125% of SPY) exceeded typical average (63%), representing an extreme outlier event. On benchmark up days, portfolio worst returns are much milder (-1.30% to -2.58%).</li>
            </ul>
        </div>

        <h2>📊 Visualizations</h2>

        <div class="charts-grid">
            <div class="chart-container">
                <h3>2. Cumulative Returns</h3>
                <img src="charts/2_cumulative_returns.png" alt="Cumulative Returns">
            </div>

            <div class="chart-container">
                <h3>3. Capture Ratios Comparison</h3>
                <img src="charts/3_capture_ratios.png" alt="Capture Ratios">
            </div>

            <div class="chart-container">
                <h3>4. Hit Rates on Down Days</h3>

                <div class="explanation-box">
                    <p><strong>Reading the Chart:</strong> Each bar shows the percentage of days the portfolio was non-negative (≥0%) when that benchmark declined. Higher bars indicate stronger downside protection.</p>
                    <p><strong>Baseline:</strong> Random chance would yield ~50%. Values below 50% indicate the portfolio tends to move with the benchmark (positive correlation), but may decline less on average.</p>
                </div>

                <img src="charts/4_hit_rates.png" alt="Hit Rates">

                <div class="insight-box">
                    <h4>Key Insights</h4>
                    <ul>
                        <li><strong>Best Protection:</strong> QQQ (42.5%) - portfolio avoids losses on 42.5% of Nasdaq down days</li>
                        <li><strong>Weakest Protection:</strong> IWM (34.0%) - portfolio declines on 66% of Russell 2000 down days</li>
                        <li><strong>Interpretation:</strong> Hit rates of 34-42% indicate moderate positive correlation with benchmarks. The portfolio tends to move in the same direction but with reduced magnitude (see downside capture ratios).</li>
                        <li><strong>ALL Down Days (37.7%):</strong> When all major benchmarks (SPY, QQQ, DIA, IWM) decline simultaneously, the portfolio still avoids losses 37.7% of the time, demonstrating some defensive characteristics.</li>
                    </ul>
                </div>
            </div>

            <div class="chart-container">
                <h3>5. Return Distribution Analysis</h3>

                <div class="explanation-box">
                    <p><strong>Reading the Chart:</strong> Box plots show the distribution of daily returns. The box contains 50% of returns (25th to 75th percentile). Whiskers show the typical range. Dots indicate outliers.</p>
                    <p>A narrower box indicates more consistent daily returns. A wider box indicates more variable daily returns.</p>
                </div>

                <img src="charts/5_return_distributions.png" alt="Return Distributions">

                <div class="insight-box">
                    <h4>Understanding Return Distributions</h4>
                    <p><strong>What the chart reveals:</strong></p>
                    <ul>
                        <li><strong>Box width:</strong> Shows consistency of returns. Narrower = more predictable, wider = more variable</li>
                        <li><strong>Median line position:</strong> If centered in box, returns are symmetric. If off-center, returns are skewed</li>
                        <li><strong>Outlier dots:</strong> Represent extreme return days. More dots = more frequent extreme movements</li>
                        <li><strong>Box position:</strong> Whether mostly above/below zero shows tendency toward gains or losses</li>
                    </ul>
                </div>
            </div>

            <div class="chart-container">
                <h3>6. Volatility Analysis</h3>"""

    # Calculate volatility statistics from cumulative returns
    cum_df_data = pd.read_csv(os.path.join(html_dir, "cumulative_returns.csv"), index_col=0)
    daily_ret_calc = (cum_df_data + 1).pct_change().fillna(0)

    vol_stats = []
    assets = ['Portfolio_ret', 'SPY_ret', 'QQQ_ret', 'DIA_ret', 'IWM_ret']
    for asset in assets:
        if asset in daily_ret_calc.columns:
            returns = daily_ret_calc[asset] * 100
            asset_name = asset.replace('_ret', '')
            vol_stats.append({
                'Asset': asset_name,
                'Volatility': returns.std(),
                'Mean_Return': returns.mean(),
                'Min': returns.min(),
                'Max': returns.max()
            })

    vol_df = pd.DataFrame(vol_stats)
    portfolio_vol = vol_df[vol_df['Asset'] == 'Portfolio']['Volatility'].values[0]

    html_content += """

                <h4 style="margin-top: 25px; margin-bottom: 12px; color: #0173B2;">📊 Volatility Statistics</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Asset</th>
                            <th>Daily Volatility (Std Dev)</th>
                            <th>Volatility vs Portfolio</th>
                            <th>Mean Daily Return</th>
                            <th>Range (Min/Max)</th>
                        </tr>
                    </thead>
                    <tbody>"""

    for _, row in vol_df.iterrows():
        asset = row['Asset']
        vol = row['Volatility']
        mean_ret = row['Mean_Return']
        vol_ratio = vol / portfolio_vol if asset != 'Portfolio' else 1.0

        # Color code based on volatility
        row_class = 'low-vol' if vol < portfolio_vol else ('high-vol' if vol > portfolio_vol * 1.2 else '')

        vol_vs_port = f"Baseline" if asset == 'Portfolio' else f"{vol_ratio:.2f}x"

        html_content += f"""
                        <tr class="{row_class}">
                            <td><strong>{asset}</strong></td>
                            <td class="metric-value">{vol:.3f}%</td>
                            <td>{vol_vs_port}</td>
                            <td>{mean_ret:+.3f}%</td>
                            <td>{row['Min']:.2f}% / {row['Max']:.2f}%</td>
                        </tr>"""

    html_content += """
                    </tbody>
                </table>

                <div class="insight-box">
                    <h4>Portfolio Volatility Summary</h4>
                    <ul>"""

    # Generate dynamic insights based on actual data
    spy_vol = vol_df[vol_df['Asset'] == 'SPY']['Volatility'].values[0]
    qqq_vol = vol_df[vol_df['Asset'] == 'QQQ']['Volatility'].values[0]

    vol_reduction_spy = ((spy_vol - portfolio_vol) / spy_vol) * 100
    vol_reduction_qqq = ((qqq_vol - portfolio_vol) / qqq_vol) * 100

    html_content += f"""
                        <li>Portfolio volatility: {portfolio_vol:.3f}% (daily std dev)</li>
                        <li>SPY volatility: {spy_vol:.3f}% ({vol_reduction_spy:+.0f}% vs Portfolio)</li>
                        <li>QQQ volatility: {qqq_vol:.3f}% ({vol_reduction_qqq:+.0f}% vs Portfolio)</li>
                        <li><strong>Portfolio volatility compared to benchmarks:</strong></li>
                        <li style="margin-left: 20px;">{abs(vol_reduction_spy):.0f}% higher than SPY ({spy_vol:.3f}%)</li>
                        <li style="margin-left: 20px;">{abs(vol_reduction_qqq):.0f}% lower than QQQ ({qqq_vol:.3f}%)</li>
                        <li style="margin-left: 20px;">Portfolio sits between these two in terms of daily fluctuation</li>
                        <li>Higher volatility indicates more daily fluctuation but does not necessarily mean higher downside risk (see downside capture ratios).</li>
                    </ul>
                </div>
            </div>

            <div class="chart-container">
                <h3>7. Average Returns: Up vs Down Days</h3>
                <img src="charts/6_avg_returns_up_down.png" alt="Average Returns">
            </div>

            <div class="chart-container">
                <h3>8. Drawdown Comparison</h3>

                <div class="explanation-box">
                    <p><strong>What is Drawdown?</strong> Drawdown measures how far below the previous high point (peak) an investment has fallen. It's calculated as: (Current Value - Running Maximum) / Running Maximum × 100%</p>
                    <p><strong>Reading the Chart:</strong></p>
                    <ul>
                        <li><strong>0% (top line):</strong> Portfolio is at a new all-time high</li>
                        <li><strong>Negative values:</strong> Portfolio is below its previous peak (e.g., -15% means 15% below highest value)</li>
                        <li><strong>Deeper dips:</strong> Larger losses from peak values</li>
                        <li><strong>Recovery:</strong> Line moving back toward 0% shows recovery toward previous highs</li>
                    </ul>
                    <p><strong>What It Tells You:</strong> Shows pain tolerance (unrealized losses during downturns), recovery speed (how quickly you bounce back), and relative performance (whether your portfolio experiences smaller or larger drawdowns than benchmarks). Shallower drawdowns indicate better downside protection.</p>
                </div>

                <img src="charts/7_drawdown.png" alt="Drawdown">
            </div>
        </div>

        <div class="footer">
            <p>Portfolio Analysis Tool | Generated by visualize.py</p>
        </div>
    </div>
</body>
</html>
"""

    # Write HTML dashboard
    html_path = os.path.join(html_dir, "index.html")
    with open(html_path, 'w', encoding='utf-8') as f:
        f.write(html_content)

    print(f"✓ HTML dashboard saved to {html_path}")
    return True


def main():
    """Main execution function."""
    # Get directory from command line argument, default to "current"
    html_dir = sys.argv[1] if len(sys.argv) > 1 else "current"

    print("=" * 60)
    print("Portfolio Visualization Generator")
    print(f"Input directory: {html_dir}/")
    print("=" * 60)

    # Check if data files exist
    required_files = [
        "capture_stats.csv",
        "summary_stats.csv",
        "cumulative_returns.csv",
        "weights_used.csv"
    ]

    missing = []
    for fname in required_files:
        if not os.path.exists(os.path.join(html_dir, fname)):
            missing.append(fname)

    if missing:
        print("\n❌ ERROR: Missing required data files:")
        for fname in missing:
            print(f"   - {html_dir}/{fname}")
        print("\nPlease run analyze.py first to generate the data.")
        return 1

    # Generate visualizations
    charts_ok = generate_charts(html_dir)
    if not charts_ok:
        print("\n⚠️  Charts generation failed, but continuing with HTML...")

    # Generate HTML dashboard
    html_ok = generate_html_dashboard(html_dir)

    if html_ok:
        print("\n" + "=" * 60)
        print("✓ Visualization complete!")
        print(f"  Open: {html_dir}/index.html")
        print("=" * 60)
        return 0
    else:
        print("\n❌ HTML generation failed")
        return 1


if __name__ == "__main__":
    exit(main())
